#version 430 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in; // 64 local threads is apparently sweet spot

layout(std430, binding = 0) buffer BlockData {
    uint occuMask[524288];
    uint blockData[];
};

layout(rgba32f, binding=0) uniform image2D prePass; // prepass has lighting data on bottom, add value to Y to offset

// player position
uniform float pPosX;
uniform float pPosY;
uniform float pPosZ;

// player direction
uniform float pDirX;
uniform float pDirY;
uniform float pDirZ;

// screen
uniform int screenWidth = 800;
uniform int screenHeight = 600;

// time
uniform float iTime;

// constants
const int passRes = 4;
const int bounces = 3;

// block data getter
uint getData(uint m) {
    uint idx = m >> 2u; // divide by 4
    uint bit = (m & 3u) * 8u; // which byte in that uint
    return (blockData[idx] >> bit) & 0xFFu;
}

// random number generator for light rays.
float seededRandom(vec2 co) {
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

// rotation matrices for light rays, yoinked ts from stack overflow.
mat3 basisFromNormal(vec3 n) {
    vec3 h = normalize(abs(n.x) > 0.5 ? vec3(0.0, 1.0, 1.0) : vec3(1.0, 0.0, 1.0));
    vec3 t = normalize(cross(h, n));
    vec3 b = cross(n, t);
    return mat3(t, b, n);
}

vec3 sampleHemisphere(vec2 u) {
    float phi = 2.0 * 3.1415 * u.x;
    float cosTheta = sqrt(1.0 - u.y);
    float sinTheta = sqrt(u.y);
    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
}

vec3 randomHemisphereDirection(vec3 normal, vec2 rand2) {
    mat3 basis = basisFromNormal(normal);
    vec3 localDir = sampleHemisphere(rand2);
    return normalize(basis * localDir);
}

// morton encoding/decoding
uint part1by2(uint x) {
    x &= 0x000003FFu;
    x = (x | (x << 16)) & 0x030000FFu;
    x = (x | (x << 8))  & 0x0300F00Fu;
    x = (x | (x << 4))  & 0x030C30C3u;
    x = (x | (x << 2))  & 0x09249249u;
    return x;
}

uint morton3D(uvec3 p) {
    return part1by2(p.x) | (part1by2(p.y) << 1) | (part1by2(p.z) << 2);
}

// camera shizzle
vec3 getRayDir(vec2 fragCoord, vec2 res, vec3 lookAt, float zoom) {
    vec2 uv = (fragCoord - 0.5 * res) / res.y;
    vec3 f = normalize(lookAt);
    vec3 r = normalize(cross(vec3(0.0,1.0,0.0), f));
    vec3 u = cross(f,r);
    return normalize(f + zoom * (uv.x*r + uv.y*u));
}

// main raymarching loop.
void main() {
    // gets fragment coordinates
    ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 preSizeOffset = ivec2(0,imageSize(prePass).y/2); // offset to bottom half of prepass, where light is stored.

    //imageStore(prePass, fragCoord+preSizeOffset, vec4(1.0)); // debug light storage.
    //return;

    // initial voxel position and normals.
    vec4 lowResData = imageLoad(prePass, fragCoord);

    // last frames lighting data.
    vec4 lightData = imageLoad(prePass, fragCoord+preSizeOffset);

    // important data from low res pass.
    float dist = lowResData.w; // distance to first voxel.
    vec3 normal = lowResData.xyz; // normals for offset.

    // initial voxel position.
    vec3 lookAt = vec3(pDirX, pDirY, pDirZ);
    vec3 rd = getRayDir(fragCoord, vec2(screenWidth,screenHeight)/passRes, lookAt, 1.0);

    vec3 ro = vec3(pPosX,pPosY,pPosZ) + rd*dist;
    ivec3 vp = ivec3(floor(ro)); //starting position.

    // attenuation for light.
    float attenuation = 1.0;

    // marches done amount of time relative to bounces.
    for (int l = 0; l < bounces; l++) {

        // recalculate ray direction with random direction offset from normal.
        vec2 rand = vec2(seededRandom(vec2(vp.x+iTime, vp.y-iTime)),seededRandom(vec2(vp.z+iTime, vp.x-iTime)));
        lookAt = randomHemisphereDirection(normal, rand);
        rd = getRayDir(fragCoord, vec2(screenWidth,screenHeight)/passRes, lookAt, 1.0);

        // voxel space setup.
        ivec3 stride = ivec3(sign(rd));
        // inverse of rd, made to be non 0.
        vec3 dr = 1.0 / max(abs(rd), vec3(1e-6));
        // distance to first voxel boundary.
        vec3 bound;
        bound.x = (rd.x > 0.0) ? (float(vp.x) + 1.0 - ro.x) : (ro.x - float(vp.x));
        bound.y = (rd.y > 0.0) ? (float(vp.y) + 1.0 - ro.y) : (ro.y - float(vp.y));
        bound.z = (rd.z > 0.0) ? (float(vp.z) + 1.0 - ro.z) : (ro.z - float(vp.z));

        vec3 tMax = bound * dr; // how far to first voxel boundary per axis.

        for (int i = 0; i < 1024; i++) {

            uint m = morton3D(vp);
            uint data = getData(m);
            if (data > 0u) { // upon hitting voxel either store light, or attenuate and break.
                attenuation *= dot(normal, rd);
                break;
            }

            if (tMax.x <= tMax.y && tMax.x <= tMax.z) { // X is closest
                vp.x += stride.x;
                tMax.x += dr.x;
                normal = vec3(stride.x,0.0,0.0);
            } else if (tMax.y <= tMax.z) {             // Y is closest
                vp.y += stride.y;
                tMax.y += dr.y;
                normal = vec3(0.0,stride.y,0.0);
            } else {                                  // Z is closest
                vp.z += stride.z;
                tMax.z += dr.z;
                normal = vec3(0.0,0.0,stride.z);
            }

        }
    }
    imageStore(prePass, fragCoord+preSizeOffset, vec4(max(attenuation,0.1), lightData.xyz)); // stores current light, and last few frames get shifted over.
}