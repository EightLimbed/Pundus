#version 430 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in; // 64 local threads is apparently sweet spot

layout(std430, binding = 0) buffer BlockData {
    uint occuMask[524288];
    uint blockData[];
};

layout(rgba32f, binding=0) uniform image2D lightPrePass; // prepass has lighting data on bottom, add value to Y to offset

// screen
uniform int screenWidth = 800;
uniform int screenHeight = 600;

// time
uniform float iTime;

// block data getter
uint getData(uint m) {
    uint idx = m >> 2u; // divide by 4
    uint bit = (m & 3u) * 8u; // which byte in that uint
    return (blockData[idx] >> bit) & 0xFFu;
}

// morton encoding/decoding
uint part1by2(uint x) {
    x &= 0x000003FFu;
    x = (x | (x << 16)) & 0x030000FFu;
    x = (x | (x << 8))  & 0x0300F00Fu;
    x = (x | (x << 4))  & 0x030C30C3u;
    x = (x | (x << 2))  & 0x09249249u;
    return x;
}

uint morton3D(uvec3 p) {
    return part1by2(p.x) | (part1by2(p.y) << 1) | (part1by2(p.z) << 2);
}

// camera shizzle
vec3 getRayDir(vec2 fragCoord, vec2 res, vec3 lookAt, float zoom) {
    vec2 uv = (fragCoord - 0.5 * res) / res.y;
    vec3 f = normalize(lookAt);
    vec3 r = normalize(cross(vec3(0.0,1.0,0.0), f));
    vec3 u = cross(f,r);
    return normalize(f + zoom * (uv.x*r + uv.y*u));
}

// main raymarching loop.
void main() {
    ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 preSize = imageSize(prePass);
    float dist = imageLoad(prePass, fragCoord).x; // big distance.
}