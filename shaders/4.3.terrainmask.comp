#version 430 core

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in; // 64 local threads is apparently sweet spot

layout(std430, binding = 0) buffer BlockData {
    uint blockData[];
};

layout(std430, binding = 1) buffer OccuMask {
    uint occuMask[];
};

// constants
const int passRes = 4;
const uint maskAmount = passRes*passRes*passRes/4u;

// player
uniform int cPPosX = 0;
//uniform int cPPosY;
uniform int cPPosZ = 0;

void recalcMask(uint m) { // pass chunk/mask index (cm) in to recalculate
    // indexing for bitpacking
    uint idx = m >> 5u; 
    uint bit = m & 31u;
    // every two uints checked as group to see if empty.
    uint nm = m*maskAmount;
    bool empty = true;
    for (uint i = 0u; i < maskAmount; i++) {
        if (blockData[nm+i] != 0u ) {
            empty = false;
            break;
        }
    }
    if (empty) {
        atomicOr(occuMask[idx], 1u << bit);
    } else {
        atomicAnd(occuMask[idx], ~(1u << bit));
    }
}

// morton encoding/decoding
uint part1by2(uint x) {
    x &= 0x000003FFu;
    x = (x | (x << 16)) & 0x030000FFu;
    x = (x | (x << 8))  & 0x0300F00Fu;
    x = (x | (x << 4))  & 0x030C30C3u;
    x = (x | (x << 2))  & 0x09249249u;
    return x;
}

uint morton3D(uvec3 p) {
    return part1by2(p.x) | (part1by2(p.y) << 1) | (part1by2(p.z) << 2);
}

void main() {
    ivec3 cp = ivec3(gl_GlobalInvocationID)+ivec3(cPPosX,0,cPPosZ);
    uint cm = morton3D(cp) % 16777216;
    recalcMask(cm);
}