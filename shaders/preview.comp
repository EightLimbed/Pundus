#version 430 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in; // 64 local threads is apparently sweet spot

layout(std430, binding = 0) buffer BlockData {
    uint blockData[];
};

layout(std430, binding = 1) buffer OccuMask {
    uint occuMask[];
};

layout(rgba32f, binding=0) uniform image2D prePass;

// player position
uniform float pPosX;
uniform float pPosY;
uniform float pPosZ;

// player direction
uniform float pDirX;
uniform float pDirY;
uniform float pDirZ;

// input
uniform bool click;
uniform int brush;
uniform int brushSize;

// time
uniform float iTime;

// constants
const float passRes = 4.0;
const uint maskAmount = uint(passRes*passRes*passRes)/4u;

// block data getter
uint getData(uint m) {
    uint idx = m >> 2u; // divide by 4
    uint bit = (m & 3u) * 8u; // which byte in that uint
    return (blockData[idx] >> bit) & 0xFFu;
}

void setData(uint m, uint value) { // pass
    uint i = m >> 2u;
    uint byteShift = (m & 3u) * 8u;

    uint clearMask = ~(0xFFu << byteShift);
    uint insert = (value & 0xFFu) << byteShift;

    atomicAnd(blockData[i], clearMask);
    atomicOr(blockData[i], insert);
}

void recalcMask(uint m) { // pass chunk/mask index (cm) in to recalculate
    // indexing for bitpacking
    uint idx = m >> 5u; 
    uint bit = m & 31u;
    // every two uints checked as group to see if empty.
    uint nm = m*maskAmount;
    bool empty = true;
    for (uint i = 0u; i < maskAmount; i++) {
        if (blockData[nm+i] != 0u) {
            empty = false;
            break;
        }
    }
    if (empty) {
        atomicOr(occuMask[idx], 1u << bit);
    } else {
        atomicAnd(occuMask[idx], ~(1u << bit));
    }
}

// morton encoding/decoding
uint part1by2(uint x) {
    x &= 0x000003FFu;
    x = (x | (x << 16)) & 0x030000FFu;
    x = (x | (x << 8))  & 0x0300F00Fu;
    x = (x | (x << 4))  & 0x030C30C3u;
    x = (x | (x << 2))  & 0x09249249u;
    return x;
}

uint morton3D(uvec3 p) {
    return part1by2(p.x) | (part1by2(p.y) << 1) | (part1by2(p.z) << 2);
}

// camera shizzle
vec3 getRayDir(vec2 fragCoord, vec2 res, vec3 lookAt, float zoom) {
    vec2 uv = (fragCoord - 0.5 * res) / res.y;
    vec3 f = normalize(lookAt);
    vec3 r = normalize(cross(vec3(0.0,1.0,0.0), f));
    vec3 u = cross(f,r);
    return normalize(f + zoom * (uv.x*r + uv.y*u));
}

bool posOutside(ivec3 pos, ivec3 mini, ivec3 maxi) {
    return (pos.x >= maxi.x || pos.x < mini.x || pos.y >= maxi.y || pos.y < mini.y || pos.z >= maxi.z || pos.z < mini.z);
}

void main() {
    //ivec3 offset = ivec3(gl_GlobalInvocationID);
    //if (posOutside(offset, ivec3(0), ivec3(brushSize))) return;
    // camera setup.
    vec3 ro = vec3(pPosX,pPosY,pPosZ);
    vec3 rd = vec3(pDirX, pDirY, pDirZ);

    // voxel space setup.
    ivec3 stride = ivec3(sign(rd));
    // inverse of rd, made to be non 0.
    vec3 dr = 1.0 / max(abs(rd), vec3(1e-6));

    ivec3 vp = ivec3(floor(ro)); //starting position.
    // distance to first voxel boundary.
    vec3 bound;
    bound.x = (rd.x > 0.0) ? (float(vp.x) + 1.0 - ro.x) : (ro.x - float(vp.x));
    bound.y = (rd.y > 0.0) ? (float(vp.y) + 1.0 - ro.y) : (ro.y - float(vp.y));
    bound.z = (rd.z > 0.0) ? (float(vp.z) + 1.0 - ro.z) : (ro.z - float(vp.z));

    vec3 tMax = bound * dr; // how far to first voxel boundary per axis.
    ivec3 normal;

    if (tMax.x <= tMax.y && tMax.x <= tMax.z) {
        normal = ivec3(stride.x,0,0);
	} else if (tMax.y <= tMax.z) {
        normal = ivec3(0,stride.y,0);
	} else {
        normal = ivec3(0,0,stride.z);
    }
    uint m;
    uint cm;
    bool place = true;

    for (int i = 0; i < 128; i++) {

        m = morton3D(vp);
        cm = morton3D(ivec3(floor(vec3(vp)/passRes))) % 16777216;
        if (getData(m) > 0u) {
            vp -= vp % brushSize;
            place = false;
            break;
        }

		if (tMax.x <= tMax.y && tMax.x <= tMax.z) { // X is closest
			vp.x += stride.x;
            tMax.x += dr.x;
            normal = ivec3(stride.x,0,0);
		} else if (tMax.y <= tMax.z) {             // Y is closest
			vp.y += stride.y;
            tMax.y += dr.y;
            normal = ivec3(0,stride.y,0);
		} else {                                  // Z is closest
			vp.z += stride.z;
            tMax.z += dr.z;
            normal = ivec3(0,0,stride.z);
		}

	}
    if (place) return;
    for (int x = 0; x < brushSize; x++) {
    for (int y = 0; y < brushSize; y++) {
    for (int z = 0; z < brushSize; z++) {
    ivec3 change = ivec3(x,y,z);
    // breaking
    if (click) {
        m = morton3D(vp+change);
        cm = morton3D(ivec3(floor(vec3(vp+change)/passRes))) % 16777216;
        setData(m, 0u);
        recalcMask(cm);
    // placing
    } else {
        // recalculate with normal offset.
        m = morton3D(vp+change-normal*brushSize);
        cm = morton3D(ivec3(floor(vec3(vp+change)/passRes))) % 16777216;
        setData(m, brush+1);
        recalcMask(cm);
    }
    }
    }
    }
}