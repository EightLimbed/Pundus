#version 430 core

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in; // 64 local threads is apparently sweet spot

layout(std430, binding = 0) buffer BlockData {
    uint blockData[];
};

layout(std430, binding = 1) buffer OccuMask {
    uint occuMask[];
};

layout(rgba32f, binding=0) uniform image2D prePass;

// time
uniform float iTime;

// constants
const float passRes = 4.0;
const uint maskAmount = uint(passRes*passRes*passRes)/4u;

// 0 for solid, 1 for powder, 2 for water.
const int dataID[8] = {0, 0, 0, 0, 0, 0, 1, 2};

// position offsets for powders (check 5 blocks directly underneath block to move to).
const ivec3 sOffsets[5] = {ivec3(0,-1,0), ivec3(0,-1,1), ivec3(0,-1,-1), ivec3(1,-1,0), ivec3(-1,-1,0)};

// position offsets for liquids (check 9 blocks directly underneath and beside block to move to).
const ivec3 lOffsets[9] = {ivec3(0,-1,0), ivec3(0,-1,1), ivec3(0,-1,-1), ivec3(1,-1,0), ivec3(-1,-1,0), ivec3(0,0,1), ivec3(0,0,-1), ivec3(1,0,0), ivec3(-1,0,0)};

// chunk mask getter
bool checkChunk(uint m) {
    uint idx = m >> 5u; // which 32-bit term (divide by 32)
    uint bit = m & 31u; // which bit in that term (mod 32 or whatever)
    return ((occuMask[idx] >> bit) & 1u) == 0u;
}

// block data getter
uint getData(uint m) {
    uint idx = m >> 2u; // divide by 4
    uint bit = (m & 3u) * 8u; // which byte in that uint
    return (blockData[idx] >> bit) & 0xFFu;
}

void setData(uint m, uint value) { // pass
    uint i = m >> 2u;
    uint byteShift = (m & 3u) * 8u;

    uint clearMask = ~(0xFFu << byteShift);
    uint insert = (value & 0xFFu) << byteShift;

    atomicAnd(blockData[i], clearMask);
    atomicOr(blockData[i], insert);
}

void recalcMask(uint m) { // pass chunk/mask index (cm) in to recalculate
    // indexing for bitpacking
    uint idx = m >> 5u; 
    uint bit = m & 31u;
    // every two uints checked as group to see if empty.
    uint nm = m*maskAmount;
    bool empty = true;
    for (uint i = 0u; i < maskAmount; i++) {
        if (blockData[nm+i] != 0u) {
            empty = false;
            break;
        }
    }
    if (empty) {
        atomicOr(occuMask[idx], 1u << bit);
    } else {
        atomicAnd(occuMask[idx], ~(1u << bit));
    }
}

// morton encoding/decoding
uint part1by2(uint x) {
    x &= 0x000003FFu;
    x = (x | (x << 16)) & 0x030000FFu;
    x = (x | (x << 8))  & 0x0300F00Fu;
    x = (x | (x << 4))  & 0x030C30C3u;
    x = (x | (x << 2))  & 0x09249249u;
    return x;
}

uint morton3D(uvec3 p) {
    return part1by2(p.x) | (part1by2(p.y) << 1) | (part1by2(p.z) << 2);
}

void main() {
    uvec3 id = gl_GlobalInvocationID;
    uint m = morton3D(id);
    if (!checkChunk(m)) return;
    setData(morton3D(id*4), 5);
    recalcMask(m);
}