#version 430 core

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in; // 64 local threads is apparently sweet spot

layout(std430, binding = 0) buffer BlockData {
    uint blockData[];
};

layout(std430, binding = 1) buffer OccuMask {
    uint occuMask[];
};

layout(rgba32f, binding=0) uniform image2D prePass;

// time
uniform float iTime;

// player
uniform int cPPosX;
//uniform int cPPosY;
uniform int cPPosZ;

// constants
const int passRes = 4;
const uint maskAmount = uint(passRes*passRes*passRes)/4u;

// 0 for solid, 1 for powder, 2 for water.
const int dataID[10] = {2, 2, 2, 2, 2, 2, 2, 2, 0, 0};

// position offsets (check 9 blocks directly underneath and beside block to move to for liquids, or only underneath for powders).
const ivec3 offsets[8] = {ivec3(0,-1,1), ivec3(0,-1,-1), ivec3(1,-1,0), ivec3(-1,-1,0), ivec3(0,0,1), ivec3(0,0,-1), ivec3(1,0,0), ivec3(-1,0,0)};

const int offsetSizes[2] = {4,8};

// chunk mask getter
bool checkChunk(uint m) {
    uint idx = m >> 5u; // which 32-bit term (divide by 32)
    uint bit = m & 31u; // which bit in that term (mod 32 or whatever)
    return ((occuMask[idx] >> bit) & 1u) == 0u;
}

// block data getter
uint getData(uint m) {
    uint idx = m >> 2u; // divide by 4
    uint bit = (m & 3u) * 8u; // which byte in that uint
    return (blockData[idx] >> bit) & 0xFFu;
}

void setData(uint m, uint value) { // pass
    uint i = m >> 2u;
    uint byteShift = (m & 3u) * 8u;

    uint clearMask = ~(0xFFu << byteShift);
    uint insert = (value & 0xFFu) << byteShift;

    atomicAnd(blockData[i], clearMask);
    atomicOr(blockData[i], insert);
}

void recalcMask(uint m) { // pass chunk/mask index (cm) in to recalculate
    // indexing for bitpacking
    uint idx = m >> 5u; 
    uint bit = m & 31u;
    // every two uints checked as group to see if empty.
    uint nm = m*maskAmount;
    bool empty = true;
    for (uint i = 0u; i < maskAmount; i++) {
        if (blockData[nm+i] != 0u) {
            empty = false;
            break;
        }
    }
    if (empty) {
        atomicOr(occuMask[idx], 1u << bit);
    } else {
        atomicAnd(occuMask[idx], ~(1u << bit));
    }
}

// morton encoding/decoding
uint part1by2(uint x) {
    x &= 0x000003FFu;
    x = (x | (x << 16)) & 0x030000FFu;
    x = (x | (x << 8))  & 0x0300F00Fu;
    x = (x | (x << 4))  & 0x030C30C3u;
    x = (x | (x << 2))  & 0x09249249u;
    return x;
}

uint morton3D(uvec3 p) {
    return part1by2(p.x) | (part1by2(p.y) << 1) | (part1by2(p.z) << 2);
}

void main() {
    ivec3 cp = ivec3(gl_GlobalInvocationID)+ivec3(cPPosX,0,cPPosZ);
    uint cm = morton3D(cp) % 16777216;
    recalcMask(cm);
    if (!checkChunk(cm)) return; // early out on empty chunks.

    // physics.
    // loops over blocks in chunk
    for (int x = 0; x < passRes; x++) {
    for (int y = 0; y < passRes; y++) {
    for (int z = 0; z < passRes; z++) {

        ivec3 vp = cp*4+ivec3(x,y,z); // voxel position
        uint m = morton3D(vp); // voxel index

        uint data = getData(m); // voxel data

        int pID = dataID[data-1];
        if (data == 0u) continue; // skip if air.
        else if (pID == 0) continue; // skip if not physics particle.

        ivec3 fvp = vp;
        fvp.y--;
        uint fm = morton3D(fvp);
        bool grounded = getData(fm) > 0u; // checks if voxel below.

        // iterate over positions around voxel to check for non vertical movement.
        if (grounded) {
            for (int i = 0; i < offsetSizes[pID-1]; i++) {
                ivec3 mvp = vp + offsets[i]; // voxel check position
                uint mm = morton3D(mvp); // voxel check index
                uint mData = getData(mm); // voxel check data
                if (mData == 0u) { // if checked block empty
                    // move voxel.
                    setData(m, 0u);
                    setData(mm, data);
                    break;
                }
            }
        } else { // voxel falls multiple tiles downwards in one frame.
            for (int i = 0; i < 5; i++) {
                fvp.y--;
                fm = morton3D(fvp);
                if (getData(fm) > 0u) {
                    fvp.y++;
                    fm = morton3D(fvp);
                    break;
                }
            }
            setData(m, 0u);
            setData(fm, data);
        }
    }
    }
    }
}