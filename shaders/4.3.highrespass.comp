#version 430 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in; // 64 local threads is apparently sweet spot

layout(std430, binding = 0) buffer BlockData {
    uint blockData[];
};

layout(std430, binding = 1) buffer OccuMask {
    uint occuMask[];
};

layout(std430, binding = 2) buffer LightingData {
    uint AOcells;
    uint AOpart;
    float AOchange;
    ivec3 AOoffsets[][6];
};

// positions from coarse prepass
layout(rgba32f, binding=0) uniform readonly image2D prePass;

// screen data
layout(rgba32f, binding=1) uniform writeonly image2D screen;

// player position
uniform float pPosX;
uniform float pPosY;
uniform float pPosZ;

// player direction
uniform float pDirX;
uniform float pDirY;
uniform float pDirZ;

// screen
uniform int passWidth = 800;
uniform int passHeight = 600;

// time
uniform float iTime;
uniform int AOframeMod; // modulus of frame with AO subdivision, used to offset cell checks.

// render distance.
uniform float renderDist = 1024.0;

// constants
const float passRes = 4.0;
const vec3 colors[10] = {vec3(0.1,0.7,0.1), vec3(0.1,0.8,0.0), vec3(1.0,0.3,0.5), vec3(1.0,0.5,0.1), vec3(0.6,0.3,0.0), vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.1), vec3(0.2,0.8,1.0), vec3(1.0), vec3(0.4,0.6,1.0)};
const float transparencies[10] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,1.0,0.9};


// precompute constants
const ivec2 nOffsets[4] = {ivec2(0,1), ivec2(0,-1), ivec2(1,0), ivec2(-1,0)}; // offsets for low res pass sampling.
const int colorLen = colors.length()-1;

// block data getter
uint getData(uint m) {
    uint idx = m >> 2u; // divide by 4
    uint bit = (m & 3u) * 8u; // which byte in that uint
    return (blockData[idx] >> bit) & 0xFFu;
}

// chunk mask getter
bool checkChunk(uint m) {
    uint idx = m >> 5u; // which 32-bit term (divide by 32)
    uint bit = m & 31u; // which bit in that term (mod 32 or whatever)
    return ((occuMask[idx] >> bit) & 1u) == 0u;
}

// morton encoding/decoding
uint part1by2(uint x) {
    x &= 0x000003FFu;
    x = (x | (x << 16)) & 0x030000FFu;
    x = (x | (x << 8))  & 0x0300F00Fu;
    x = (x | (x << 4))  & 0x030C30C3u;
    x = (x | (x << 2))  & 0x09249249u;
    return x;
}

uint morton3D(uvec3 p) {
    return part1by2(p.x) | (part1by2(p.y) << 1) | (part1by2(p.z) << 2);
}

// camera shizzle
vec3 getRayDir(vec2 fragCoord, vec2 res, vec3 lookAt, float zoom) {
    vec2 uv = (fragCoord - 0.5 * res) / res.y;
    vec3 f = normalize(lookAt);
    vec3 r = normalize(cross(vec3(0.0,1.0,0.0), f));
    vec3 u = cross(f,r);
    return normalize(f + zoom * (uv.x*r + uv.y*u));
}

float getAmbientOcclusion(ivec3 vp, vec3 normal) {
    float occ = 1.0;
    vp -= ivec3(normal);
    // face id
    int face = (normal.x > 0.0) ? 0 : (normal.y > 0.0) ? 1 : (normal.z > 0.0) ? 2 : (normal.x < 0.0) ? 3 : (normal.y < 0.0) ? 4 : 5;
    for (int i = 0; i < AOpart; i++) {
        ivec3 offset = AOoffsets[i+AOframeMod][face];

        uint m = morton3D(vp - offset);
        uint data = getData(m);
        float t = transparencies[data-1];
        if (data > 0u) {
            occ -= AOchange*t; // adjusted for block transparency, squared to account for skylight.
        }
    }
    return occ;
}

float getSkyLight(ivec3 vp, vec3 normal, vec3 rd, vec3 ld) {

    // early return for instant intercept.
    if (dot(normal, ld) > 0.0) return 0.3;

    // add normal offset to vp.
    vp -= ivec3(normal);

    // diffuse raymarched.
    float diffuse = 1.0;
    vec3 ro = vp;

    // voxel space setup.
    ivec3 stride = ivec3(sign(ld));
    // inverse of rd, made to be non 0.
    vec3 dr = 1.0 / max(abs(ld), vec3(1e-6));

    // distance to first voxel boundary.
    vec3 bound;
    bound.x = (ld.x > 0.0) ? (1.0) : (0.0);
    bound.y = (ld.y > 0.0) ? (1.0) : (0.0);
    bound.z = (ld.z > 0.0) ? (1.0) : (0.0);

    
    vec3 tMax = bound * dr; // how far to first voxel boundary per axis.
    for (int i = 0; i < 128; i++) {

        if (tMax.x <= tMax.y && tMax.x <= tMax.z) { // X is closest
			vp.x += stride.x;
            tMax.x += dr.x;
		} else if (tMax.y <= tMax.z) {             // Y is closest
			vp.y += stride.y;
            tMax.y += dr.y;
		} else {                                  // Z is closest
			vp.z += stride.z;
            tMax.z += dr.z;
		}
    
        // check chunk
        uint m = morton3D(vp);
        uint data = getData(m);
        if (data > 0u) {
            diffuse *= 0.9; // in shadow
            if (diffuse < 0.4) return 0.4; // early out
        }
    
    }
    // specular.
    rd.xy = -rd.xy;
    vec3 halfDir = normalize(-rd + ld);

    float specularStrength = max(dot(normal, -halfDir), 0.0);
    float specular = pow(specularStrength, 32.0)*2.0;

    return diffuse+specular; // full or partial light
}

// main raymarching loop. get rid of normals here when lighting working.
void main() {

    // gets position from thread invocation.
    ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);

    //if (fragCoord.x >= passWidth || fragCoord.y >= passHeight)
    //return;

    // crosshair
    vec2 adjustFrag = fragCoord - vec2(passWidth,passHeight)/2;
    if (dot(adjustFrag,adjustFrag) < 6.0) return;

    // low res prepass reading.
    ivec2 texel = ivec2(fragCoord) / int(passRes); // integer division, gets image coordinate.

    float dist = imageLoad(prePass, texel).x;
    
    // prevents skipping with neighbor distances.
    for (int i = 0; i < 4; i++) {
        dist = min(dist, imageLoad(prePass, texel+nOffsets[i]).x);
    }

    imageStore(screen, fragCoord, vec4(colors[colorLen],1.0)); // background color.

    if (dist > renderDist) return;

    dist = max(dist-8.0, 0.0); // safety.
    //float depth = dist/1024.0;

    // camera setup.
    vec3 lookAt = vec3(pDirX, pDirY, pDirZ);
    vec3 rd = getRayDir(fragCoord.xy, vec2(passWidth,passHeight), lookAt, 1.0);

    vec3 ro = vec3(pPosX,pPosY,pPosZ) + rd*dist;

    // voxel space setup.
    ivec3 stride = ivec3(sign(rd));
    
    vec3 dr = 1.0 / max(abs(rd), vec3(1e-6)); // inverse of rd, made to be non 0.

    ivec3 vp = ivec3(floor(ro)); //starting position.

    vec3 bound; // distance to first voxel boundary.
    bound.x = (rd.x > 0.0) ? (float(vp.x) + 1.0 - ro.x) : (ro.x - float(vp.x));
    bound.y = (rd.y > 0.0) ? (float(vp.y) + 1.0 - ro.y) : (ro.y - float(vp.y));
    bound.z = (rd.z > 0.0) ? (float(vp.z) + 1.0 - ro.z) : (ro.z - float(vp.z));

    vec3 tMax = bound * dr; // how far to first voxel boundary per axis.

    // normals
    vec3 normal;
    if (tMax.x <= tMax.y && tMax.x <= tMax.z) {
        normal = vec3(stride.x,0.0,0.0);
	} else if (tMax.y <= tMax.z) {
        normal = vec3(0.0,stride.y,0.0);
	} else {
        normal = vec3(0.0,0.0,stride.z);
    }

    float attenuation = 0.0;
    vec3 color = vec3(0.0);
    vec3 oldColor = vec3(0.0);

    for (int i = 0; i < 10000; i++) {

        float d = distance(ro,vp)+dist;
        if (d > renderDist) return; // no artifact

        // check voxel
        uint m = morton3D(vp);
        uint data = getData(m);
        

        // attenuate based on color and transparency.
        if (data > 0u) {
            float t = transparencies[data-1];
            vec3 c = colors[data-1];
            if (oldColor != c) {
                attenuation += t;
                color += c*t;
            }
            oldColor = c;
        }

        if (attenuation >= 1.0) {
             // -1 to go to 0 in array when 0 is air.
            float skyLight = getSkyLight(vp, normal, rd, vec3(cos(iTime*0.1), 0.717,sin(iTime*0.1))); // light from sun direction.
            float ambientOcclusion = getAmbientOcclusion(vp, normal);
            vec3 shaded = color*ambientOcclusion*skyLight/attenuation; // shading.
            // apply distance fog.
            float percent = d/float(renderDist);
            float atten = pow(percent, 8.0);
            imageStore(screen, fragCoord, vec4(shaded * (1.0 - atten) + atten * colors[colorLen], 1.0));
            return;
        }

		if (tMax.x <= tMax.y && tMax.x <= tMax.z) { // X is closest
			vp.x += stride.x;
            tMax.x += dr.x;
            normal = vec3(stride.x,0.0,0.0);
		} else if (tMax.y <= tMax.z) {             // Y is closest
			vp.y += stride.y;
            tMax.y += dr.y;
            normal = vec3(0.0,stride.y,0.0);
		} else {                                  // Z is closest
			vp.z += stride.z;
            tMax.z += dr.z;
            normal = vec3(0.0,0.0,stride.z);
		}

	}
}