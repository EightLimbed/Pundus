#version 430 core

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in; // 64 local threads is apparently sweet spot

layout(std430, binding = 0) buffer VoxelData {
    uint bitCloud[1024];
    uint prefixArray[1024];
    uint blockData[];
};

// morton encoding/decoding
uint part1by2(uint x) {
    x &= 0x000003FFu; // 10 bits
    x = (x | (x << 16)) & 0x030000FFu;
    x = (x | (x << 8))  & 0x0300F00Fu;
    x = (x | (x << 4))  & 0x030C30C3u;
    x = (x | (x << 2))  & 0x09249249u;
    return x;
}

uint morton3D(uvec3 id) {
    return part1by2(id.x) | (part1by2(id.y) << 1) | (part1by2(id.z) << 2);
}

// checks if voxel is solid
bool checkVoxel(uint m) {
    uint idx = m >> 5u; // which 32-bit term (divide by 32)
    uint bit = m & 31u; // which bit in that term (mod 32 or whatever)
    return ((bitCloud[idx] >> bit) & 1u) != 0u;
}

uint getDataIndex(uint m) { 
    uint i = m >> 5u; // divide by 32 

    uint bitI = m & 31u; // bit within term

    uint term = bitCloud[i]; // term number

    uint count = prefixArray[i]; // solids before this voxel in term
    uint mask = (bitI == 0u) ? 0u : (term & ((1u << bitI) - 1u)); 
    uint offset = bitCount(mask); // number of solids before this term

    return count + offset;
}

void setData(uint i, uint value)
{
    uint termI = i >> 2u;
    uint byteI = (i & 3u) * 8u;

    uint mask = ~(0xFFu << byteI);
    uint insert = (value & 0xFFu) << byteI;

    //atomicAnd(blockData[uintIndex], clearMask);  // clear old byte
    atomicOr(blockData[termI], insert);  // set new byte
}

void main(){
    uvec3 id = gl_GlobalInvocationID;
    uvec3 local = id & 31u;
    uint m = morton3D(local);

    if(checkVoxel(m)){
        setData(getDataIndex(m), id.y);
    }
}