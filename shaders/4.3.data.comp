#version 430 core

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in; // 64 local threads is apparently sweet spot

layout(std430, binding = 0) buffer VoxelData {
    uint bitCloud[1024];
    uint prefixArray[1024];
    uint blockData[];
};

// morton encoding/decoding
uint part1by2(uint x) {
    x &= 0x000003FFu; // 10 bits
    x = (x | (x << 16)) & 0x030000FFu;
    x = (x | (x << 8))  & 0x0300F00Fu;
    x = (x | (x << 4))  & 0x030C30C3u;
    x = (x | (x << 2))  & 0x09249249u;
    return x;
}

uint morton3D(uvec3 id) {
    return part1by2(id.x) | (part1by2(id.y) << 1) | (part1by2(id.z) << 2);
}

bool checkVoxel(uint m){
    uint wordIdx = m >> 5u;
    uint bitIdx  = m & 31u;
    return ((bitCloud[wordIdx] >> bitIdx) & 1u) != 0u;
}

uint getDataIndex(uint m) { 
    uint wordIndex = m >> 5u; // divide by 32 

    uint bitIndex = m & 31u; // bit within term

    uint term = bitCloud[wordIndex]; // term number

    uint baseCount = prefixArray[wordIndex]; // solids before this voxel in term
    uint localMask = (bitIndex == 0u) ? 0u : (term & ((1u << bitIndex) - 1u)); 
    uint localOffset = bitCount(localMask); // number of solids before this term

    return baseCount + localOffset;
}

void main(){
    uvec3 id = gl_GlobalInvocationID;
    uvec3 local = id & 31u;
    uint m = morton3D(local);

    if(checkVoxel(m)){
        blockData[getDataIndex(m)] = id.y;
    }
}